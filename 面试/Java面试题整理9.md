## **1.**请你说一下抽象类和接口的区别

- 接口中只能有抽象方法，在JDK8以后增加了默认方法；抽象类中可以有抽象方法，亦可以有非普通方法
- 接口中的成员变量都是常量（被final static 修饰），而抽象类中的成员变量可以是常量，也可以是变量
- 接口没有构造方法，也不能被实例化；抽象类中有抽象方法，但是不能直接实例化，需要通过其实现类来实例化
- 接口可以多实现，而抽象类只能单继承。
- 接口是对某一个行为的抽象，而类更多的是对一个事物的抽象。

------

## **2.Java的好处**

- Java吸取了C++的优点，同时抛弃了多继承，指针的复杂的概念。简单易用
- Java是一门OOP语言
- Java可以跨平台，做到一次编译，到处运行。JVM是跨平台的关键，在运行程序之前,Java源代码（.java）需要经过编译器,将源代码翻译成字节码（.class）,但字节码不能直接运行,所以必须通过JVM将字节码翻译成特定平台的机器码运行程序。但跨平台的是Java程序、而不是JVM,所以需要在不同平台下安装不同版本的JVM。
- 提供丰富的内置库
- 对Web应用有良好的支持

------

## **3.Java的基本数据类型和引用类型**

- 基本数据类型：byte, short, int, float, double, long, boolean, char.
- 引用数据类型：String, 对象，集合，基本数据包装类型

------

## **4.请说说多线程**

- 线程是操作系统调度的最小单元,它可以让一个进程并发地处理多个任务,也叫轻量级进程。
- 一个进程的多个线程之间共享系统资源，使用多线程会给开发人员带来显著的好处。
- 优点：减少程序响应时间；提高CPU利用率；创建和切换线程开销小；数据共享效率高；简化程序结构
- 缺点：可能产生死锁

------

## **5.说一下Final关键字**

- 修饰类，则该类为最终类，不可以再被继承
- 修饰方法，则该方法为最终方法，不可以被重写，但可以被重载
- 修饰变量，则该关键字为常量，定义时需要赋值，且一旦赋值后值不可以再次修改。当修饰的变量为引用类型的变量时，地址不可以更改，但是引用指向的值可以变化

------

## **6.**String、StringBuffer、Stringbuilder有什么区别

- **对象创建的区别**：String可以直接字符串赋值创建，或者new String()创建，前者会判断字符串常量池中是否存在，如果存在直接引用，不存在则创建一个在字符串常量池中，后者会在堆内存中new一个对象，同时如果字符串常量池中没有值相同的，也会给字符串常量池创建一个。StringBuilder和Stringbuffer则都abstractStringBuilder的子类，需要在堆内存中new一个
- **值是否可变的区别**：String由于final修饰的原因，其值是不可改变的，若要改变，只能采用引用改变来达到值改变的效果。StringBuilder和StringBuffer都可以实现对值的修改，常用方法有append()方法等。
- **线程安全区别：**String和StringBuffer是线程安全的，StringBuilder是线程不安全的。

------

## **7.如何保证线程安全**

------

## **8.**说说static修饰符的用法

- **static方法** 静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。static方法没有this关键字，因为this关键字是随着对象的创建才存在的。**可以通过类名.方法名调用，无论这个类是不是静态类**
- **static变量** static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。
- **static代码块** 在类被加载时加载一次，可以给静态变量赋值
- **static类** 静态类只可以是内部类

------

## **9.Java的反射**

**定义：**JAVA的反射机制就是指JAVA在运行过程中，通过获取任意一个类的字节码文件对象，都可以获取这个类的相对应的信息，包括成员变量和成员方法。这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

**使用：**类名.class 对象.getClass() Class.forName(全类名)

**方法：**getDeclaredConstructors()，获取类声明的所有构造方法，getFields()：获得类的所有公共字段，getDeclaredMethods()：获得类声明的所有方法

**应用：**Spring IOC容器通过反射装载Bean，动态代理在invoke方法中通过反射调用被代理类的方法， DispatcherServlet通过反射来调用指定Controller中的指定方法，并通过反射对参数进行赋值

------

## **10.== 和eqals()的区别**

- 首先==是运算符，equals()是方法
- equals只能比较两个引用类型的变量是否相等，==既可以比较两个值变量，也可以比较两个引用变量
- 当==比较两个值类型变量时，比较的是值，即使不是同一个数据类型，比如int a = 1, float b = 1.0，也相等；当比较引用类型时，比较的是两个变量的地址是否相同
- equals在比较两个对象时，默认是比较的是两个对象的地址，如果重写了，则按照重写的方法比较。

## **11.Java 8的一些新特性**

- lamuda表达式：实现将一个函数作为方法的参数传递，替代了之前的匿名内部类，实现了函数式编程

```java
public class Demo {
    public static void main(String[] args) {
        // 实现类
        Addable a = new AddableImpl();
        useAdd(a);
        // 匿名内部类
        Addable a1 = new Addable() {
            @Override
            public int add(int a, int b) {
                return a + b;
            }
        };
        useAdd(a1);
        // 使用lambda
        // 实际上lambda就是对匿名内部类的一种简化，lanmda的返回值就是该接口的一个实现类对象
        Addable a2 = (int c, int d) -> {
            return c + d;
        };
        useAdd(a2);
    }
    public static void useAdd(Addable a) {
        int sum = a.add(1, 1);
        System.out.println(sum);
    }
}

// 表达式的简写
// Lambda表达式省略
// 1标准形式
Addable add = (int a, int b) -> {return a + b;};
// 2参数类型可以不写
Addable add1 = (a, b) -> {return a + b;};
// 3只有一条语句 可以不写分号和大括号,且这个条语句是return的 return也省略
Addable add2 = (a, b) -> a + b;
```

- 方法引用，可以将已经实现的方法作为实现接口中某一个方法的操作。list.forEach(System::out::println);
- DateTime API
- 接口中增加了默认方法
- 集合操作类Collections静态类

------

## **12.HashMap底层原理**

- **实现方式** HashMap是基于数组+单链表+红黑树的方式实现的。

- **存储过程** 

- - 首先使用hashCode方法计算出哈希值，然后根据一定的哈希函数，比如取余计算出应该存放的数组下标。
	- 根据下标找到链表的头结点或者树的根节点，判断是否产生哈希冲突。如果没有产生冲突，则直接插入到链表或者树中。
	- 如果产生哈希冲突，则需要调用equals方法判断两个key是否相等，如果相等，则覆盖原数据，否则将元素添加到链表或者树中。
	- 当链表长度大于8且数组容量超过64的时候，链表升级为红黑树。转化目的是提高检索速度，从O(n)到O(logn)

  ![image-20230206194846123](https://raw.githubusercontent.com/liyuxuan7762/MyImageOSS/master/md_images/image-20230206194846123.png)

- **数组扩容** 哈希表中的数组默认长度为16，每次扩容内容翻一倍，当负载因子超过0.75的时候便开始扩容
- **线程安全** hashMap为线程不安全的，可以使用SycnHashMap代替
- **1.7 1.8区别** 1.7 数组+链表 1.8 数组+链表+红黑树。1.7链表头插法，1.8尾插法

**为什么要将链表转化为红黑树？**

- 每次遍历一个链表，平均查找的时间复杂度是 O(n)，n 是链表的长度。红黑树有和链表不一样的查找性能，由于红黑树有自平衡的特点，可以防止不平衡情况的发生，所以可以始终将查找的时间复杂度控制在 O(log(n))。
- 最初链表还不是很长，所以可能 O(n) 和 O(log(n)) 的区别不大，但是如果链表越来越长，那么这种区别便会有所体现。所以为了提升查找性能，需要把链表转化为红黑树的形式。红黑树的查找性能介于链表和AVL树之间。

**为什么不直接使用红黑树？**

- 在绝大多数的情况下，只要哈希函数设计的合理，数据一般分布的是比较均匀的，很少有数据长度会超过8，因此如果全部都改成红黑树的话，那么会导致空间大量的浪费。红黑树的一个Node的大小是链表Node的两倍。

**为什么使用头插法，区别是什么？**

- 头插法会导致扩容后链表的顺序发生改变，在多线程的情况下还会产生死锁问题

**扩容时机**

**在jdk1.7中数组的容量是在HashMap初始化的时候就已经赋予，而在jdk1.8中是在put第一个元素的时候才会赋予数组容量，而put第一个元素的时候也会调用resize()方法**

容量：capacity ，默认16。

加载因子：loadFactor，默认是0.75

阈值：threshold，默认12。threshold=capacity*loadFactor；当元素个数超过阈值时，就会触发扩容。

HashMap数组中元素个数超过阈值，即触发扩容。

例如：默认情况下，**容量16，加载因子0.75，阈值12**，当HashMap中的元素个数超过12，会把数组大小扩大为2*容量=2*16=32，即容量变为原来的2倍，阈值=新容量*加载因子 = 32*0.75 = 24。然后重新计算出每个元素在数组中的位置。

**扩容为什么是两倍？**

- 初始容量为2的幂幂数，扩容后的容量也是2的幂数，则元素在新表中的位置要么不动，要么满足新位置=原长度+原位置。
- 容量为2的幂数则可以使元素均匀的散布hashmap中，减少hash碰撞

**为什么长度大于8的时候扩容？**

- 如果 hashCode 分布良好，也就是 hash 计算的结果离散好的话，那么红黑树这种形式是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006。这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。这体现了时间和空间平衡的思想.
- 当然，这是理想的算法，但不妨某些用户使用HashMap过程导致hashCode分布离散很差的场景，这个时候再转换为红黑树就是一种很好的退让策略。

**扩容区别**

- JDK 7的扩容的时候需要计算每一个元素的哈希值然后再存入新的数组，且由于使用了尾插发，导致链表顺序逆转
- JDK 8 扩容的时候只需要判断原来的hash值新增的那个bit是1还是0就可以了。如果结果不同，则新位置等于老位置+数组长度；否则等于原始位置

https://www.jianshu.com/p/cae4adaf4daa

https://blog.51cto.com/u_15344989/5012601

https://blog.csdn.net/zlp1992/article/details/104376309

**为什么等于新数组长度+原始位置**

位置计算公式等于 (数组长度-1) & 哈希值

数组长度-1和每次都扩充的是2的幂次是为了保证数组长度-1对应的二进制都是1

比如数组长度为8，那么就是111，数组长度16，那么就是1111

根据公式：(数组长度-1) & 哈希值，那么&左边部分都是1，在进行与运算的时候不会影响到右边的哈希值。

假设A的哈希值二进制为0111，数组长度为8，那么扩容前的位置为 111&111 = 111

扩容以后 长度为16，则扩容后应该为 0111 & 1111，我们可以看到，后面3位实际上不会有变化，只有最高位有变化

如果哈希值的最高位和1向与，结果为0，那么位置不会有变化。如果是1，则位置需要调整。

**只需要判断元素hash值最高的一位是0还是1即可确定位置**

数组长度为8 0111

数组长度为16 1111

数组长度-1所对应的二进制数都是1 所以在按位与的时候不会影响原始的数据，只有在最高位的时候可能会出现不同

因为进行按位与，除了最高位以外其余位不会发生变化，因此在如果hash和新旧数组长度按位与最高位相同，那么位置就完全相同（按位与保证除了最高位都相同，现在最高位也相同，则完全相同）。如果不同，则差的值一定是数组长度 参见0111 -> 1111 扩充正好是最高位加一个1.

------

## **13.Java的异常处理**

- 异常处理机制可以让程序具有极好的容错性和健壮性,当程序运行出现了意料之外的状况时,系统会生成一个Exception对象来通知程序,**从而实现“业务功能实现部分代码”与“错误处理部分代码”分离**,使程序获得更好的可读性。
- 异常处理分为**捕获异常**，**抛出异常**，**声明异常**三种。
- 捕获异常使用try-catch-finally语句块实现、try中写业务代码，catch中写可能出现的异常处理代码，finally中写一定要执行的代码，比如资源的释放。
- 抛出异常通过throw抛出一个异常的实例
- 声明异常通过在函数签名上throws来声明异常，声明一个异常，这个异常可能抛出，也可能不抛出
- try-catch-finally try不可以省略, catch-finally不同时省略
- finally中的return一定会执行。

------

## **14.线程创建的步骤**

- 继承Thread类，重写run方法。创建Thread子类的实例,即创建了线程对象。调用该对象的start方法。**使用继承的方式创建对象，Thread类的子类中的成员变量必须要添加static关键字才能将变量变成共享变量，因为在创建线程的时候，实际上创建了多个子类的对象，如果不加static关键字，那么这些变量每一个类都有一份自己的。**
- 实现Runable接口，重写run方法。创建Runable的实现类对象，将其作为参数来创建Thread对象，调用start方法。**使用实现的方式创建线程，里面的成员变量不需要加static关键字，因为最终只创建了一个Runable接口的实现类对象，然后通过该对象再去创建Thread对象，实际上这些成员变量的数据都是共享的。因为只创建了一个对象**
- 实现Callable接口，重写call方法。创建Callable接口的实现类对象，将其作为FutureTask的参数，创建FutureTask对象，然后以FutureTask对象为参数，创建Thread对象，调用start方法。

------

## **15.Java中实现同步的方式**

- **两种方式：通过sync关键字，通过Lock对象**
- sync加在普通方法上,则锁是当前的实例（this）。  加在静态方法上,则锁是当前类的Class对象。 加在代码块上,则需要在关键字后面的小括号里,显式指定一个对象作为锁对象。
- sync没有考虑到超时机制、非阻塞形式,以及多个条件变量
- 因此,JDK的开发团队在1.5引入了Lock接口,并通过Lock支持了上述的功能。

**锁和sync的区别**

- Lock是显示锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放
- Lock只有代码块锁，synchronized有代码块锁和方法锁
- 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）

https://blog.csdn.net/m0_68808168/article/details/125777996

------

## **16.Sycn关键字**

**有多个线程并发执行一定会产生同步问题吗? 不一定，必须这些线程共享资源时才有可能产生线程不安全问题**

**同步代码块中的锁**

- 使用同步代码块的前提是多个进程的同步监视器是唯一的。
- 继承Thread类：如果是使用继承Thread类创建的类对象的话，那么同步代码块中的锁应该是类名.class, 类对象在JVM中是唯一的。或者在子类中创建一个Obj的对象作为同步监视器，但是这个对象必须使用static关键字修饰。因为我们在main方法中实际上是创建了多个Thread子类的对象，那么如果不加static，那么每一个对象中都有其自己的obj对象，那么就会导致同步监视器实际上不是唯一的。当添加了了static关键字后，所有的子类对象都是共享同一个obj对象，那么也就做到了同步监视器的唯一，从而保证了同步代码块的安全性。
- 实现Runable接口。如果采用这种方式的话，那么同步代码块中的同步监视器通常设置为this，也就是调用这个方法的对象。因为我们在main方法中只创建了一个Runable接口的实现类，因此实际上尽管我们创建了多个线程，但是最终调用run的还是Runable接口的实现类对象，它只创建了一个，因此this也都是代指的一个，所以可以保证同步监视器的唯一性。当然，我们也可以自己去创建一个obj对象作为同步监视器，但是这时候我们就不需要添加static关键字了，因为我们只创建了一个对象，因此obj也是唯一的。

**使用sycn同步代码块的好处的和不足**

- 使用以后解决了线程的不安全问题
- 但是使用后在同步代码块中的代码实际上变成了串行执行

**使用同步代码块的原则**

- 不能少包含，因为少包含起不到保护线程安全的作用
- 也不能多包含，因为多包含会降低程序的并发性，在某些情况下还会改变程序的执行逻辑

**同步方法**

- 同步方法是对于同步代码块的简化，如果一个方法中所有的代码都是需要同步代码块包含的，那么直接设置该方法为同步方法。
- 同步方法中默认的同步监视器为this。
- 实现接口。实现接口的方式可以直接将一个方法前面添加sync关键字即可，系统默认的锁就是this，可以保证线程的安全。
- 继承Thread类。采用这种方法如果只是简单的在方法前面添加sync关键字是无法线程安全的。因为sync方法的默认同步监视器是this，但是采用继承方式this不可以作为同步监视器，因此需要将sync方法声明为static方法才可以。如果是静态的同步方法，那么默认的锁就是**对象.class。**

------

## **17.单例模式**

![image-20230206194435321](https://raw.githubusercontent.com/liyuxuan7762/MyImageOSS/master/md_images/image-20230206194435321.png)

```java
public class MyTest {
    public static void main(String[] args) {
        Bank instance = Bank.getInstance();
        Bank instance1 = Bank.getInstance();
        System.out.println(instance == instance1); // true
    }
}
// 实现单例模式 饿汉式
class Bank {
    // 1. 构造方法必须私有，防止在其他地方使用new创建对象
    private Bank() {}
    // 2. 在类的内部创建对象
    // 4. 因为static方法只能访问静态变量，因此要将这个设置为静态
    private static Bank instance = new Bank();
    // 3. 给外界提供一个方法用来获取创建的对象 因为不能创建对象，因此需要使用类名调用方法，因此要设置成static
    public static Bank getInstance() {
        return instance;
    }
}
```

```java
// 实现单例模式 懒汉式
class Bank {
    // 1. 构造方法必须私有，防止在其他地方使用new创建对象
    private Bank() {}
    // 2. 在类的内部创建对象
    // 4. 因为static方法只能访问静态变量，因此要将这个设置为静态
    private static Bank instance = null;
    // 3. 给外界提供一个方法用来获取创建的对象 因为不能创建对象，因此需要使用类名调用方法，因此要设置成static
    public static Bank getInstance() {
        if (instance == null)
            instance = new Bank();
        return instance;
    }
}
```

懒汉式和饿汉式

- **饿汉式是天然线程安全的**，因为在创建的同时就已经把对象创建了，这样即使后续多个线程调用getinStance方法的时候，也都返回的是同一个对象
- **懒汉式是线程不安全的**。因为在getinStance时，如果此时对象没有创建，第一个线程判断为null，进入if，然后阻塞，第二个线程判断也是null，也会进入if，那么就会导致创建两个对象，破坏了单例模式的条件

**单例模式的应用**

![image-20230206194545488](https://raw.githubusercontent.com/liyuxuan7762/MyImageOSS/master/md_images/image-20230206194545488.png)

```java
class Bank {
    // 2. 在类的内部创建对象
    // 4. 因为static方法只能访问静态变量，因此要将这个设置为静态
    private static Bank instance = null;

    // 1. 构造方法必须私有，防止在其他地方使用new创建对象
    private Bank() {
    }
    // 3. 给外界提供一个方法用来获取创建的对象 因为不能创建对象，因此需要使用类名调用方法，因此要设置成static

    // 修改成线程安全的 可以直接添加sync关键字
//    public static Bank getInstance() {
//        if (instance == null)
//            instance = new Bank();
//        return instance;
//    }
    // 这两者是等价的 但是效率不高，因为当bank实例不为空的时候，后面的实际上就不需要串行的来去判断了
//    public static Bank getInstance() {
//        synchronized (Bank.class) {
//            if (instance == null)
//                instance = new Bank();
//            return instance;
//        }
//    }
    // 效率高
    public static Bank getInstance() {
        if(instance  == null) {
            synchronized (Bank.class) {
                if (instance == null)
                    instance = new Bank();
            }
        }
        return instance;
    }
}
```

Lock锁

使用ReentrantLock对象创建一个锁对象。如果是通过继承的方式实现多线程，注意是否需要在创建lock对象的时候加上static关键字

**锁和sync的区别**

- 相同点：都可以实现线程的同步
- 不同点：sync在执行完同步代码后自动释放同步监视器；Lock需要手动启动锁lock(), 也需要手动的去释放锁 unlock()

![image-20230206194613391](https://raw.githubusercontent.com/liyuxuan7762/MyImageOSS/master/md_images/image-20230206194613391.png)

**线程通信**

- Sleep是Thread的静态方法，调用sleep方法可以让当前正在运行的线程进入睡眠状态，即暂时停止运行指定的单位时间。并且该线程在睡眠期间不会释放对象锁。
- Wait是Object类的一个方法，调用wait方法可以让当前线程进入等待唤醒状态，并释放锁。该线程会处于等待唤醒状态直到另一个线程调用了object对象的notify方法或者notifyAll方法
- Nofity：唤醒一个线程，其他线程依然处于wait的等待唤醒状态，如果被唤醒的线程结束时没调用notify，其他线程就永远没人去唤醒，只能等待超时，或者被中断
- NotifyAll：所有线程退出wait的状态，开始竞争锁，但只有一个线程能抢到，这个线程执行完后，其他线程又会有一个幸运儿脱颖而出得到锁
- 以上的所有方法只能在sync代码块或者sync方法中才可以调用。并且这些方法的调用者必须是sync中的同步监视器，否则出错IllegalMonitorStateException
- 这些方法是写在obj类中的，原因是因为同步监视器可以是任何一个类的对象，所以为了保证所有的类的对象都可以调用上述的方法，只能将这些方法写在obj类中，因为obj类是所有类的父类

**wait和sleep的异同**

- 定义位置不同：sleep是定义在Thread类中，wait是Object类中的方法
- 使用位置不同：sleep可以在任何地方使用，wait只能在同步方法或同步代码块中使用。
- 是否释放锁的不同：sleep不释放锁，wait释放锁

**创建线程的方式**

- 继承Thread类，重写run方法。创建Thread子类的实例,即创建了线程对象。调用该对象的start方法。**使用继承的方式创建对象，Thread类的子类中的成员变量必须要添加static关键字才能将变量变成共享变量，因为在创建线程的时候，实际上创建了多个子类的对象，如果不加static关键字，那么这些变量每一个类都有一份自己的。**
- 实现Runable接口，重写run方法。创建Runable的实现类对象，将其作为参数来创建Thread对象，调用start方法。**使用实现的方式创建线程，里面的成员变量不需要加static关键字，因为最终只创建了一个Runable接口的实现类对象，然后通过该对象再去创建Thread对象，实际上这些成员变量的数据都是共享的。因为只创建了一个对象**
- 实现Callable接口，重写call方法。创建Callable接口的实现类对象，将其作为FutureTask的参数，创建FutureTask对象，然后以FutureTask对象为参数，创建Thread对象，调用start方法。实际上是FutureTask实现了Runable接口。使用futureTask对象的get方法可以获取到方法的返回值
- 使用线程池创建线程

**Callable相较于Runable的一些好处**

- call方法支持返回值，通过futureWork的get方法可以获取
- 支持抛出异常
- 支持泛型

**线程池**

- **背景：**对于需要经常创建和销毁线程的情况，如果每次都真的去创建线程，那么会带来极大的系统开销。比如说在移动端快速滑动页面，那么页面的滑动通常是由主进程完成的，但是加载每一条信息和图片通常是由其他的线程负责的，一个线程负责加载一条记录，加载完成后销毁线程。这样在快速滑动的时候，就会涉及到大量的线程的创建和销毁，如果不用线程池的话，那么对系统的开销很大。

- **思路：**采用线程池的方式，提前创建好多个线程，如果需要使用线程则直接去线程池中取，执行完毕后也不销毁线程，而是放回到线程池中。

- **好处**

- - 提高了相应的速度（降低了线程创建的耗时）
	- 降低了资源的消耗（不需要重复创建线程）
	- 便于线程的管理
	- corePoolSize 核心池的大小
	- maximumPoolSize 最大线程数
	- keepAliveTime 线程没有任务的时候最长保持多长时间

```java
public class MyTest {
    public static void main(String[] args) {
        // 创建线程池
        // 1. 创建线程池
        ExecutorService executorService = Executors.newFixedThreadPool(15);
        executorService.execute(new Window()); // 2. 执行使用实现Runnable接口实现的线程
        // 2. executorService.submit(); 执行使用实现Callable接口实现的线程
        // 3. 关闭线程池
        executorService.shutdown();
        
        // 设置线程池的相关参数
        ThreadPoolExecutor service = (ThreadPoolExecutor) executorService;
        service.setCorePoolSize(10);
        service.setKeepAliveTime();
    }
}
class Window implements Runnable {
    @Override
    public void run() {
    }
}
```

