## **1.关于进程和线程**

**什么是进程**

进程是把指令加载给CPU，数据加载到内存并执行的程序实例

**进程的特点**

- 一个进程可以包含多个线程
- 每一个进程有自己独立的内存空间，同一个进程的多个线程之间共享内存空间
- 进程切换起来开销较大，不同进程之间不共享内存

 **什么是线程**

- **线程是轻量级的进程**
- **一个线程就是一个指令流的执行**

**两者区别**

- 线程是进程的子集。一个进程可以包含多个线程
- 不同进程之间内存空间不共享，同一个进程的多个线程之间内存共享
- 进程是操作系统资源分配的最小单位，线程是操作系统调度的最小单位
- 线程更加轻量化，切换线程的开销相对较小

------

## **2.并行和并发**

- 并行是只多个线程同时执行
- 并行是值多个线程轮流使用CPU资源，在宏观上是并行的
- 一般来说对于单核CPU的机器，线程执行是并发的，对于多核CPU来讲，线程执行是既有并行也有并发的

------

## **3.同步执行和异步执行**

- 一个程序需要运行完了有结果了才能进行下一个线程，这样这个程序就会堵塞其他的程序，这就是同步，异步就是这个程序在运行的时候我仍然可以不管他运行别的程序
- 多线程可以将同步程序变为异步的，从而增加系统资源的利用率

- 比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，这么cpu只能等5秒，啥都不能做。

------

## **4.Java中实现多线程的方式**

- 继承Thread类，重写run方法。创建Thread子类的实例,即创建了线程对象。调用该对象的start方法。**使用继承的方式创建对象，Thread类的子类中的成员变量必须要添加static关键字才能将变量变成共享变量，因为在创建线程的时候，实际上创建了多个子类的对象，如果不加static关键字，那么这些变量每一个类都有一份自己的。**
- 实现Runable接口，重写run方法。创建Runable的实现类对象，将其作为参数来创建Thread对象，调用start方法。**使用实现的方式创建线程，里面的成员变量不需要加static关键字，因为最终只创建了一个Runable接口的实现类对象，然后通过该对象再去创建Thread对象，实际上这些成员变量的数据都是共享的。因为只创建了一个对象**
- 实现Callable接口，重写call方法。创建Callable接口的实现类对象，将其作为FutureTask的参数，创建FutureTask对象，然后以FutureTask对象为参数，创建Thread对象，调用start方法。实际上是FutureTask实现了Runable接口。使用futureTask对象的get方法可以获取到方法的返回值
- 使用线程池创建线程

------

## **5.什么是线程的上下文切换**

多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。

**原因**

- 线程的 cpu 时间片用完(每个线程轮流执行，看前面并发的概念)
- 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法

------

## **6.Start和Run的区别**

- start方法是线程从就绪变为启动状态的方法，而run方法是线程启动之后需要执行的代码
- 如果直接调用run方法，相当于使用thread对象调用它的一个普通方法而已，调用者是线程对象，并且是在主线程中执行的。

------

## **7.如何来停止一个线程**

- 使用Stop方法，这种方法会破坏业务原子性。不推荐使用
- 使用interrupt标记位实现

```java
if (this.isInterrupted()) {
    System.out.println("线程终止, 停止for循环.");
    return;
}
```

------

## **9.Sleep和yield的区别**

- 使用sleep后，线程进入到阻塞状态，无法参与CPU资源的竞争
- 使用yield后线程进入到就绪状态，可以参与CPU资源的竞争

------

## **10.Sleep和yield为什么是静态方法**

- 只有正在运行的线程本身才可以调用sleep和yield方法，其他线程调用是无意义的。CPU资源只能由当前的线程主动让出。如果设置成成员方法，那么其他线程可以通过获取正在运行线程的实例化对象调用sleep来抢占CPU资源。

------

## **11.如何实现T1 T2 T3的顺序执行**

- 使用join方法。一个进程调用了join方法，就将其他的线程挂起。仅当这个线程执行完毕后才可以执行其他线程。使用join方法。Join方法使得线程之间的并行执行变为串行执行。

http://t.zoukankan.com/hzcjd-p-13740590.html

------

## **12.sleep，yiled，wait，join 对比**

------

## **13.什么是线程安全**

- 当多个线程同时访问公共数据时，数据不会发生错误，那么就是线程安全的。

------

## **14.什么是临界区**

- 访问邻接资源的代码成为临界区

------

## **15.**什么是不可变对象，它对写并发应用有什么帮助？

- 不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变。常见的有String，基本数据类型的包装类等。
- 由于一旦创建后数据不可以被修改，因此这些不可变对象天然就是线程安全的。

------

## **16.为什么wait, notify和notifyAll这些方法不在thread类里面？**

- 这些方法是写在obj类中的，原因是因为同步监视器可以是任何一个类的对象，所以为了保证所有的类的对象都可以调用上述的方法，只能将这些方法写在obj类中，因为obj类是所有类的父类

------

## **17.**为什么wait和notify方法要在同步块中调用？

- 以上的所有方法只能在sync代码块或者sync方法中才可以调用。并且这些方法的调用者必须是sync中的同步监视器，否则出错IllegalMonitorStateException

------

## **18.什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？**

------

## **19.死锁问题**

**什么是死锁？**

死锁是只在多线程的环境下，多个线程因抢占资源而造成的一种僵局，所有线程都处于阻塞状态下，若无外力作用，将一直僵持下去。

**死锁产生的四个条件**

- 互斥条件：资源不能被共享，只能由一个线程同时使用
- 请求保持条件：已经拥有部分资源的进程可以继续申请新的资源
- 不剥夺：已经分配的资源除非线程自己释放，否则将不可以被其他线程剥夺
- 循环等待：系统中出现等待环路，所有的线程都在等待相邻线程释放资源

**死锁预防**

- 破坏互斥条件：允许进程同时访问某些资源，这一点在很多情况下不现实
- 破坏不剥夺条件：当一个线程已经拥有了某些资源后，再去申请其他的资源，但是此时申请资源失败了，则这个进程需要释放掉本身所占有的资源，然后重新申请所有资源
- 破坏请求保持：可以使用资源预分配策略。在进程执行前就分配他所需要的所有资源。如果此时进程的所有资源得不到满足，则不分配任何资源
- 破坏循环等待：将所有的资源进行编号。进程在申请资源的时候必须按照资源需要递增的顺序申请

**死锁的解除**

- 剥夺资源：从其他进程中剥夺资源给死锁进程来解除死锁
- 撤销进程：以最小的代价撤销死锁进程

------