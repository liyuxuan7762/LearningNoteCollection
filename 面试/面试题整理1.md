### 1.Java面向对象有哪些特征，如何应用
三大特性：封装，继承，多态
* 封装（提高代码的安全性）：
	* 隐藏类内部的结构，可以保护类内部数据，也可以在不影响使用的墙况下改变类的内部结构
	* 属性的封装：比如类中的private字段，用户不可以直接修改属性，必须通过提供的方法来访问数据，在其中可以加入相关的逻辑控制，限制外界对属性的不合理操作，保护类的内部数据的安全性
	* 方法的封装：将方法的实现进行封装，调用者不需要关系方法的实现；修改方法内部代码时不影响外部的调用
	封装好的代码可以重复使用，提高了代码的复用性。参考SQLHelper
* 继承（提高代码的复用性）：
	* 本质上是一般到特殊的关系，Java中通过extends关键字实现继承，一旦继承，子类拥有父类所有的方法的和属性（private修饰的不可继承）
	* 对于一些重复的代码，可以使用继承的方式，来增加代码的复用性。
	
> 继承在项目中比较常用的就是在实体类上，将一些实体类中都有的公共属性可以提取成一个父类，让其他的子类都继承这个父类来降低冗余代码

*  多态（增加代码的灵活性和可移植性）
	* 三个要素：两个类存在继承关系；存在方法重写；父类引用指向子类对象
	* 由于子类对象需要重写父类的方法，因此实现是随意的，所以代码可以很灵活，且方便移植。降低程序的耦合性
	* 弊端：不能调用子类中的特有方法

多态复习
对于成员变量：编译看左边，执行看左边
对于方法：变异看左边，执行看右边

多态举例
https://blog.csdn.net/weixin_31720909/article/details/114243560

> 关于多态的理解：
>
> 多态的实现方式处理有上面的子类继承父类的方法外，还有通过实现接口的方式实现多态。最常见的使用就是`UserService`和`UserServiceImpl`通过让接口引用指向实现类对象来实现引用。可以实现程序的灵活性和可移植性。
>
> 比如一开始项目使用的是MySQL，那么`UserServiceImpl`是基于MySQL实现的，后期想换Oracle，那么只需要使用Oracle的逻辑重新实现`UserService`接口即可，其他的都不需要动

---

### 2.HashMap原理是什么，在Java 7和Java 8中有什么区别
* 哈希Map是一个Map，其中Key是存储数据的哈希值，值则为要存储的数据。
* 哈希Map是线程不安全的，多个进程可以同时访问哈希Map，有可能会导致数据的不一致。需要线程安全的话可以使用synchronizedMap或者ConcurrentHashMap

**Java 7 实现**
![在这里插入图片描述](https://img-blog.csdnimg.cn/eb2fd82039374d689fbd0c767685690b.png)


基于数组和单向链表实现。在查询的过程中，先根据数据计算出哈希值，然后直接根据索引查询到相应的数组元素，然后在该元素对应的单向链表中从到依次遍历得到元素。时间复杂度O(n).

**Java 8实现**

![在这里插入图片描述](https://img-blog.csdnimg.cn/cfe2ba7a05c848b9b3846e0162ff5ddd.png)
最大的改进是采用了红黑树，链表元素超过8个以后，就不再使用单向链表进行存储，而是采用了红黑树，之前时间复杂度是O(n)，在引入了红黑树以后O(logn)

---
### 3.ArrayList和LinkedList有什么区别？
* 这两个都实现了List接口，区别在在于ArrayList底层实现基于数组，LinkedList基于双向链表
* 数组：在内存中占用连续的存储单元，可以实现随机读取，获取数据的时间复杂度为O(1)。特点：读取数据非常快，但是插入或删除数据非常慢，需要移动大量元素
* 链表：在内存中不占用连续存储单元，对于数据存储只能顺序访问，查找一个元素的时间复杂度为O(n)。特点：添加和删除数据时间非常快，读取数据时间慢。此外，由于每一个节点除了存储数据以外还要存储两个指针，因此占用空间比数组多。

---

### 4.高并发中的集合（很难 了解即可）
* 第一代的集合都是线程安全的，比如Vector和HashTable，但是效率低下，且不是所有的情况都需要线程安全集合
* 因此推出了ArrayList和HashMap等线程不安全集合
* 在需要线程安全时可以使用syncList或者syncMap代替
* 第三代线程安全类 concurrentHashMap CopyonWriteArrayList等
---
### 5.Java中重写和重载的区别

![在这里插入图片描述](https://img-blog.csdnimg.cn/657c71349bfd4858b43070b92b67ba78.png)
---

### 6.抽象类和接口的区别
**抽象类**
* 抽象类和抽象方法都必须使用abstract关键字修饰
* 抽象类中不一定有抽象方法，但是抽象方法必须在抽象类中
* 抽象类不能实例化，必须通过子类进行实例化
* 抽象类的子类要么重写所有抽象方法，或者子类也是抽象类
* 抽象类的成员变量可以是变量，也可以是常量
* 抽象类有构造方法，但是不能实例化

**接口**
* 接口中的方法都是抽象方法，被public修饰
* 接口中的成员变量都是常量
* 接口没有构造方法，不能被实例化
![在这里插入图片描述](https://img-blog.csdnimg.cn/0e6ed36059af46cba5904c95216b4ce0.png)
---

### 7.如何声明类不会被继承
使用Final修饰的类，不可以被继承。
如果一个中的所有方法都没有重写的需要，当前类没有子类也罢，就可以使用final修饰类。

---

### 8.Java中==和equals的区别
* 一个是运算符，一个是方法
*  =在对比基本数据类型的时候比较的是值，在引用数据类型时比较的是地址
* equals用来比较对象。如果该对象没有重写equals方法，那么比较的就是两个对象的地址；否则则根据重写的方法里面的逻辑进行比较

```java
@Override
public boolean equals(Object obj) {
    if(this==obj){ return true;}
    if(obj==null){ return false;}
    if(obj instanceof Student){
        Student s = (Student)obj;
        if(this.name.equals(s.getName())&&this.age == s.getAge()){
            return true;
        }
    }
    return false;
}
```

---

### 9.String StringBuilder StringBuffer的区别
String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。下面的操作实际上是在Java的堆内存的常量池中创建了一个字符串abc，当需要修改变量s的值时，如果常量池中已经存在bcd，则将s的指针指向bcd的地址，否则创建一个bcd常量。**因此，string无法在不改变指向地址的情况下改变字符串的值。**

```java
String s = "abc";
s = "bcd"
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/e85fd42b27b74fd6960f88da725ee1b7.png)


* StringBuilder可以对字符串对象直接进行修改。底层通过数组来存储字符串
SB包含两部分，value保存着指向字符串的指针。count保存的是当前实际存储的字符数。
使用append方法时，就是在这个数组的后面添加元素。
当数组满了以后，会进行扩充，将原有数组全部拷贝到新数组中，将value中的地址修改为新数组的地址。
* StringBuffer效率更低，因为是线程安全的，其方法都有sync修饰，StringBuilder是线程不安全的。